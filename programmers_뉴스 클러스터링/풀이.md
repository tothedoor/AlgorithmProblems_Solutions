# **[프로그래머스] - 뉴스 클러스터링**

<br/>

## **문제**
문제는 [링크](https://programmers.co.kr/learn/courses/30/lessons/17677)를 참고 바란다.

<br/>

## **풀이 아이디어 및 설명** 
일단 str1과 str2의 다중 집합의 원소들은 대소문자를 구분하지 않고 비교되야 한다. 
그래서 String.toLowerCase()를 통해 두 문자열 모두 소문자로 변환했다.  

그 다음 sub 문자열들을 탐색하며 알파벳인 경우에만 ArrayList에 추가하도록 했다.  
두 문자열에 대해 각각 list에 추가하도록 한 다음에는 한 list에 대해 하나씩 탐색하며  
두 번째 list에 동일한 것이 존재하는 경우 두 번째 list에서는 해당 sub 문자열을 지운다.  
그 다음 합집합과 교집합의 원소의 개수를 증가시킨다. 존재하지 않는 경우에는  
합집합의 개수만 증가시킨다.

첫 번째 list에 대해 탐색을 마친후 두 번째 list를 탐색한다.  
두 번째 list에는 첫 번째 list와 중복되는 것이 없으므로 list의 size만큼 합집합의 개수를 증가시킨다.

후에는 교집합의 크기 / 합집합의 크기 * 65536을 return하도록 했다. 다만 여기서 65536까지  
곱해진 이후에 소숫점의 버림이 일어나야 하므로 마지막에 int로 형변환을 실시하여  
return 하도록 했다.

<br/>

## **발생했던 문제 및 해결**
처음에는 map을 이용하여 sub string을 key로, 그 개수를 value로 하여 각 문자열에 대해  
HashMap을 생성하여 해결하려 했다. 하지만 
동일한 sub String의 개수가 각 문자열에서 다른 경우에 각 map에는 정상적으로 저장되지만 value를 조회시  
더 큰 값으로 동일하게 나오는 문제가 발생하였다. 문제 원인을 찾으려 했지만 정확한 원인은  
찾지 못했다. 다만 HashMap이 thread Safe하지 않아 발생하는 문제로 추정되었다. 그래서  
ConcurrentHashMap(Thread safe함)으로 변환하여 해보았지만 해결되지 않았다. 그래서 map이   
아닌 다른 것을 사용하기 위해 고민 끝에 ArrayList를 사용하였다. 각 sub String들을 모두  
ArrayList에 넣은 후에 탐색하는 방식은 map을 사용했을 때와 동일하게 유지하였다.  
변경 후 실행하니 정답처리를 확인할 수 있었다.